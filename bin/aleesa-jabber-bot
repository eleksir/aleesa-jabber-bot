#!/usr/bin/perl

use 5.018;
use strict;
use warnings;
use utf8;
use open qw(:std :utf8);
use English qw( -no_match_vars );

use version; our $VERSION = qw(1.0);

my $workdir;

# before we run, change working dir
BEGIN {
	use Cwd qw(chdir abs_path);
	my @CWD = split (/\//, abs_path ($PROGRAM_NAME));
	if ($#CWD > 1) { $#CWD = $#CWD - 2; }
	$workdir = join ('/', @CWD);
	chdir ($workdir);
}

use lib ("$workdir/lib", "$workdir/vendor_perl", "$workdir/vendor_perl/lib/perl5");
no Cwd;
use Cwd::utf8 qw(chdir abs_path);
use POSIX qw(setgid setuid setsid);
use File::Path qw(make_path);
use File::Basename qw(basename dirname);
use conf qw(loadConf);
use botlib qw(logger);
use jabberbot qw(run_jabberbot);

sub daemonize ();
sub __fork ();

local $OUTPUT_AUTOFLUSH = 1;
my $runAsUid = $UID;

my $piddir = '/var/run/' . basename (abs_path ($PROGRAM_NAME));
my $C = loadConf ();

# if we run under root, create pid dir and set correct owner for it, same for debug log if it is defined
if ($UID == 0) {
	my $user = $C->{user};
	die "Unable to run as root, please define unprivileged user in config.json\n" unless (defined ($user));
	my ($uid, $gid) = (getpwnam ($user))[2,3];

	unless (-d $piddir) {
		make_path (
			$piddir, {
				uid   => $uid,
				group => $gid
			}
		);
	}

	if ($C->{'debug_log'}) {
		unless (-d dirname($C->{'debug_log'})) {
			make_path (
				dirname($C->{'debug_log'}), {
					uid   => $uid,
					group => $gid
				}
			);
		}
	}

# drop privs
	setgid ($gid) or die "Unable to switch to group of $user($OS_ERROR)\n";
	setuid ($uid) or die "Unable to switch to account $user($OS_ERROR)\n";
} else {
	$piddir = $workdir;
}

# double fork attach to /dev/null all stdio and go background
daemonize ();

# write pidfile
my $apath = abs_path ($PROGRAM_NAME);

unless (defined($apath)) {
	logger ("Unable to get abs_path: $OS_ERROR");
	die "Unable to get abs_path: $OS_ERROR\n";
};

my $pidfile = sprintf ('%s/%s.pid', $piddir, basename ($apath));
logger ("Creating pidfile at $pidfile");
open (my $pid, '>', $pidfile) or die "Error opening $pidfile: $OS_ERROR\n";
print $pid $PID or die "Error writing to $pidfile: $OS_ERROR\n";
close $pid;  ## no critic (InputOutput::RequireCheckedSyscalls

# set correct proctitle
$PROGRAM_NAME = abs_path ($PROGRAM_NAME);  ## no critic (Variables::RequireLocalizedPunctuationVars)

# run bot, at last
run_jabberbot ();
unlink ($pidfile) if (-f $pidfile);
exit 0;

sub daemonize () {
	__fork ();
	POSIX::setsid ();
	open (STDIN, '<', '/dev/null');   ## no critic (InputOutput::RequireCheckedSyscalls, InputOutput::RequireCheckedOpen)
	open (STDOUT, '>', '/dev/null');  ## no critic (InputOutput::RequireCheckedSyscalls, InputOutput::RequireCheckedOpen)
	open (STDERR, '>', '/dev/null');  ## no critic (InputOutput::RequireCheckedSyscalls, InputOutput::RequireCheckedOpen)
	__fork ();
	umask 0;
	return;
}

sub __fork () {
	my $pid = fork;
	die "Can't fork: $OS_ERROR\n" unless (defined ($pid));
	exit if ($pid != 0);
	return;
}

__END__
# vim: set ft=perl noet ai ts=4 sw=4 sts=4:
